<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>📊 SmartWerk Bookkeeper</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <link rel="stylesheet" href="bookkeeper.css" />
</head>
<body>
  <h1>📒 My Bookkeeper</h1>
  <a href="dashboard.html" class="btn">← Back to Dashboard</a>
  <button class="btn" onclick="exportCSV()">📁 Export CSV</button>
  <button class="btn btn-primary" onclick="exportPDF()">📄 Export PDF</button>

  <div class="filters">
    <label>Client:
      <select id="clientFilter">
        <option value="">All Clients</option>
      </select>
    </label>
    <label>Period:
      <select id="filterBy">
        <option value="all">All time</option>
        <option value="thisYear">This Year</option>
        <option value="thisMonth">This Month</option>
        <option value="lastMonth">Last Month</option>
      </select>
    </label>
    <label>From: <input type="date" id="customFrom"></label>
    <label>To: <input type="date" id="customTo"></label>
  </div>

  <div class="stats">
    <div class="card"><h2>Total Income</h2><p id="totalIncome">€0</p></div>
    <div class="card"><h2>Total Expenses</h2><p id="totalExpenses">€0</p></div>
    <div class="card"><h2>Net Profit</h2><p id="netProfit">€0</p></div>
    <div class="card"><h2>Total VAT</h2><p id="totalVat">€0</p></div>
    <div class="card">
      <h2>Annual Target</h2>
      <p>€<span id="targetValue">50,000</span></p>
      <div class="progress-container">
        <div class="progress-bar" id="targetProgress" style="width: 0%">0%</div>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>📊 Income vs Expenses</h2>
    <canvas id="summaryChart" height="100"></canvas>
  </div>
  
<div class="section">
  <h2>📊 Income by Client</h2>
  <canvas id="incomeByClientChart"></canvas>
</div>
  

  <div class="section upcoming">
    <div class="card">
      <h2>📅 Upcoming Invoice Due Dates</h2>
      <ul id="upcomingInvoices"></ul>
    </div>
    <div class="card">
      <h2>💸 Upcoming Expenses</h2>
      <ul id="upcomingExpenses"></ul>
    </div>
  </div>

  <section class="section alerts">
  <h2>🧠 Smart Suggestions</h2>
  <ul id="smartSuggestions"></ul>
</section>



  <footer>© 2025 SmartWerk</footer>

  <script type="module">

import {
  initializeApp,
  getApps,
  getApp
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import {
  getAuth,
  onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import {
  getFirestore,
  collection,
  getDocs,
  onSnapshot,
  addDoc
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAp397Ax_jaMI85vOXicOi61g64HvvA_Kg",
  authDomain: "smartwerk8520.firebaseapp.com",
  projectId: "smartwerk8520",
  appId: "1:607670981972:web:c07103c981c86860d724c1"
};

const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const $ = id => document.getElementById(id);

let summaryChart = null;

function formatCurrency(eur) {
  return "€" + (eur || 0).toLocaleString("nl-NL", {
    minimumFractionDigits: 2
  });
}

function filterByPeriod(date, filter, from, to) {
  const d = new Date(date);
  const now = new Date();
  const thisMonth = now.getMonth();
  const thisYear = now.getFullYear();
  const lastMonth = new Date(now);
  lastMonth.setMonth(thisMonth - 1);
  const fromDate = from ? new Date(from) : null;
  const toDate = to ? new Date(to) : null;

  if (fromDate && toDate) return d >= fromDate && d <= toDate;

  switch (filter) {
    case "thisMonth":
      return d.getMonth() === thisMonth && d.getFullYear() === thisYear;
    case "lastMonth":
      return d.getMonth() === lastMonth.getMonth() && d.getFullYear() === lastMonth.getFullYear();
    case "thisYear":
      return d.getFullYear() === thisYear;
    default:
      return true;
  }
}

async function loadBookkeeperData(uid) {
  const [invoiceSnap, expenseSnap, clientSnap] = await Promise.all([
    getDocs(collection(db, "users", uid, "invoices")),
    getDocs(collection(db, "users", uid, "expenses")),
    getDocs(collection(db, "users", uid, "clients"))
  ]);

  const filter = $("filterBy").value;
  const from = $("customFrom").value;
  const to = $("customTo").value;

  // 🧾 Фільтрація інвойсів
  let invoices = invoiceSnap.docs
    .map(doc => doc.data())
    .filter(i => filterByPeriod(i.invoiceDate || i.date, filter, from, to));

  // 💸 Фільтрація витрат
  let expenses = expenseSnap.docs
    .map(doc => doc.data())
    .filter(e => filterByPeriod(e.date, filter, from, to))
    // Фільтруємо тільки ті, що мають валідне число
    .filter(e => !isNaN(parseFloat(e.amount)));

  // 📊 Дохід по клієнтах
  const incomeByClient = {};
  invoices.forEach(inv => {
    if (!inv.clientName) return;
    incomeByClient[inv.clientName] = (incomeByClient[inv.clientName] || 0) + (inv.grandTotal || 0);
  });

  // 🔍 Фільтр по вибраному клієнту
  const selectedClient = $("clientFilter").value;
  if (selectedClient) {
    invoices = invoices.filter(i => i.clientName === selectedClient);
  }

  // 💰 Обчислення підсумків
  let totalIncome = 0;
  let totalVat = 0;
  let totalExpenses = 0;

  invoices.forEach(i => {
    totalIncome += parseFloat(i.grandTotal) || 0;
    totalVat += parseFloat(i.totalVat) || 0;
  });

  expenses.forEach(e => {
    totalExpenses += parseFloat(e.amount) || 0;
  });

  const netProfit = totalIncome - totalExpenses;

  // 💶 Відображення у UI
  $("totalIncome").innerText = formatCurrency(totalIncome);
  $("totalVat").innerText = formatCurrency(totalVat);
  $("totalExpenses").innerText = formatCurrency(totalExpenses);
  $("netProfit").innerText = formatCurrency(netProfit);

  // 🎯 Ціль по доходу
  const target = 50000;
  const percent = Math.min(100, Math.round((totalIncome / target) * 100));
  $("targetProgress").style.width = percent + "%";
  $("targetProgress").innerText = percent + "%";

  // 💾 Збереження для експорту
  window.__incomeByClient = incomeByClient;

  // 📂 Витрати по категоріях
  const expensesByCategory = {};
  expenses.forEach(e => {
    const cat = e.category || "Other";
    const amt = parseFloat(e.amount) || 0;
    expensesByCategory[cat] = (expensesByCategory[cat] || 0) + amt;
  });
  window.__expensesByCategory = expensesByCategory;

  // 📈 Побудова графіків і відображення
  drawChart(invoices, expenses);
  drawIncomeByClientChart(incomeByClient);
  loadUpcomingInvoices(invoices);
  loadUpcomingExpenses(expenses);
  populateClientDropdown(clientSnap.docs.map(d => d.data()));
  loadSmartSuggestions(invoices, expenses, target);

  console.log("✅ Loaded expenses:", expenses);
  console.log("💶 Total Expenses Calculated:", totalExpenses);
}

 function loadSmartSuggestions(invoices, expenses, targetIncome = 50000) {
  const suggestions = [];
  const now = new Date();
  const lastMonth = new Date(now);
  lastMonth.setMonth(now.getMonth() - 1);
  const currentMonthStr = now.toISOString().slice(0, 7);
  const prevMonthStr = lastMonth.toISOString().slice(0, 7);

  const formatDate = d => new Date(d);

  // Unpaid invoices > 30 days
  const unpaidOld = invoices.filter(i => {
    const due = formatDate(i.dueDate);
    return i.status !== "Paid" && due && (now - due) > 30 * 24 * 60 * 60 * 1000;
  });
  if (unpaidOld.length > 0) {
    suggestions.push(`📌 You have <strong>${unpaidOld.length}</strong> unpaid invoice(s) older than 30 days.`);
  }

  // Income this month vs last month
  const grouped = {};
  invoices.forEach(i => {
    const m = (i.invoiceDate || i.date || "").slice(0, 7);
    grouped[m] = (grouped[m] || 0) + (i.grandTotal || 0);
  });

  const current = grouped[currentMonthStr] || 0;
  const previous = grouped[prevMonthStr] || 0;
  if (previous > 0) {
    const diff = ((current - previous) / previous) * 100;
    if (diff < -10) {
      suggestions.push(`📉 Income dropped <strong>${Math.abs(diff).toFixed(1)}%</strong> compared to last month.`);
    }
  }

  // Avg. payment time
  const paid = invoices.filter(i => i.status === "Paid" && i.paidDate && i.invoiceDate);
  if (paid.length > 0) {
    const avgDays = Math.round(paid.reduce((sum, i) => {
      return sum + Math.max(0, (new Date(i.paidDate) - new Date(i.invoiceDate)) / (1000 * 60 * 60 * 24));
    }, 0) / paid.length);
    suggestions.push(`📆 Average payment time: <strong>${avgDays} days</strong>`);
  }

  // Target income progress
  const totalIncome = invoices.reduce((sum, i) => sum + (i.grandTotal || 0), 0);
  const percent = Math.min(100, Math.round((totalIncome / targetIncome) * 100));
  suggestions.push(`🎯 You have reached <strong>${percent}%</strong> of your annual income goal.`);

  // Expense change
  const groupedExp = {};
  expenses.forEach(e => {
    const m = (e.date || "").slice(0, 7);
    groupedExp[m] = (groupedExp[m] || 0) + (e.amount || 0);
  });

  const currExp = groupedExp[currentMonthStr] || 0;
  const prevExp = groupedExp[prevMonthStr] || 0;
  if (prevExp > 0) {
    const expDiff = ((currExp - prevExp) / prevExp) * 100;
    const direction = expDiff > 0 ? "increased" : "decreased";
    suggestions.push(`💸 Expenses have <strong>${direction}</strong> by ${Math.abs(expDiff).toFixed(1)}% this month.`);
  }

  // Render to UI
  const container = document.getElementById("smartSuggestions");
  container.innerHTML = "";
  suggestions.forEach(s => {
    const li = document.createElement("li");
    li.innerHTML = s;
    container.appendChild(li);
  });
}   


function drawChart(invoices, expenses) {
  const incomeMap = {}, expenseMap = {};

  invoices.forEach(i => {
    const m = (i.invoiceDate || i.date || "").slice(0, 7);
    incomeMap[m] = (incomeMap[m] || 0) + (i.grandTotal || 0);
  });

  expenses.forEach(e => {
    const m = (e.date || "").slice(0, 7);
    expenseMap[m] = (expenseMap[m] || 0) + (e.amount || 0);
  });

  const labels = Array.from(new Set([...Object.keys(incomeMap), ...Object.keys(expenseMap)])).sort();
  const incomeData = labels.map(m => incomeMap[m] || 0);
  const expenseData = labels.map(m => expenseMap[m] || 0);

  const ctx = $("summaryChart").getContext("2d");
  if (summaryChart) summaryChart.destroy();

  summaryChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "Income", data: incomeData, backgroundColor: "#22c55e" },
        { label: "Expenses", data: expenseData, backgroundColor: "#ef4444" }
      ]
    },
    options: {
      responsive: true,
      plugins: { legend: { position: "top" } }
    }
  });
}
   let incomeClientChart = null;

function drawIncomeByClientChart(data) {
  const ctx = document.getElementById("incomeByClientChart").getContext("2d");
  if (incomeClientChart) incomeClientChart.destroy();

  const labels = Object.keys(data);
  const values = Object.values(data);

  incomeClientChart = new Chart(ctx, {
    type: "pie", // або "bar" для кругової 
    data: {
      labels,
      datasets: [{
        label: "Income (€)",
        data: values,
        backgroundColor: labels.map((_, i) => `hsl(${i * 40}, 70%, 60%)`)
      }]
    },
    options: {
      //indexAxis: "y",
      responsive: true,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (context) => "€" + context.raw.toFixed(2)
          }
        }
      },
      scales: {
        x: {
          ticks: {
            callback: (val) => "€" + val
          }
        }
      }
    }
  });
} 

function loadUpcomingInvoices(invoices) {
  const list = $("upcomingInvoices");
  list.innerHTML = "";

  const upcoming = invoices
    .filter(i => i.dueDate && new Date(i.dueDate) > new Date())
    .sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate))
    .slice(0, 5);

  if (upcoming.length === 0) {
    const li = document.createElement("li");
    li.textContent = "📭 No upcoming invoices";
    li.style.color = "#94a3b8"; // приглушений сірий
    list.appendChild(li);
    return;
  }

  upcoming.forEach(i => {
    const li = document.createElement("li");
    const due = new Date(i.dueDate).toLocaleDateString("en-GB", {
      day: "numeric", month: "short", year: "numeric"
    });
    li.textContent = `${i.clientName || "Unnamed"} – due ${due}`;
    list.appendChild(li);
  });
}

function loadUpcomingExpenses(expenses) {
  const list = $("upcomingExpenses");
  list.innerHTML = "";

  const upcoming = expenses
    .filter(e => e.date && new Date(e.date) > new Date())
    .sort((a, b) => new Date(a.date) - new Date(b.date))
    .slice(0, 5);

  if (upcoming.length === 0) {
    const li = document.createElement("li");
    li.textContent = "📭 No upcoming expenses";
    li.style.color = "#94a3b8";
    list.appendChild(li);
    return;
  }

  upcoming.forEach(e => {
    const li = document.createElement("li");
    const due = new Date(e.date).toLocaleDateString("en-GB", {
      day: "numeric", month: "short", year: "numeric"
    });
    li.textContent = `${e.category || "Expense"} – due ${due}`;
    list.appendChild(li);
  });
}

function populateClientDropdown(clients) {
  const select = $("clientFilter");
  const currentValue = select.value; // 🔸 зберігаємо поточне значення

  select.innerHTML = `<option value="">All Clients</option>`;
  clients.forEach(c => {
    if (!c.clientName) return;
    const opt = document.createElement("option");
    opt.value = c.clientName;
    opt.textContent = c.clientName;
    select.appendChild(opt);
  });

  // 🔸 Після оновлення — відновлюємо обране значення
  select.value = currentValue;
}

window.exportCSV = () => {
  const baseMetrics = [
    ["Metric", "Value"],
    ["Total Income", $("totalIncome").innerText],
    ["Total Expenses", $("totalExpenses").innerText],
    ["Net Profit", $("netProfit").innerText],
    ["Total VAT", $("totalVat").innerText],
    ["Period", getSelectedPeriodText()]
  ];

  let csvContent = "data:text/csv;charset=utf-8," + 
    baseMetrics.map(row => row.map(val => `"${val.replace(/"/g, '""')}"`).join(",")).join("\n");

  // 👉 Розширений: Доходи по клієнтам
  if (window.__incomeByClient) {
    csvContent += "\n\nIncome by Client:,";
    csvContent += "\nClient,Total Income";

    for (const [client, amount] of Object.entries(window.__incomeByClient)) {
      csvContent += `\n"${client}","€${amount.toLocaleString("nl-NL", { minimumFractionDigits: 2 })}"`;
    }
  }

  // 👉 Розширений: Витрати по категоріях (опційно)
  if (window.__expensesByCategory) {
    csvContent += "\n\nExpenses by Category:,";
    csvContent += "\nCategory,Total Expenses";

    for (const [cat, amount] of Object.entries(window.__expensesByCategory)) {
      csvContent += `\n"${cat}","€${amount.toLocaleString("nl-NL", { minimumFractionDigits: 2 })}"`;
    }
  }

  const encodedUri = encodeURI(csvContent);
  const now = new Date();
  const filename = `smartwerk-bookkeeper-${now.toISOString().slice(0, 10)}.csv`;

  const link = document.createElement("a");
  link.setAttribute("href", encodedUri);
  link.setAttribute("download", filename);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};
    function getSelectedPeriodText() {
  const filter = document.getElementById("filterBy")?.value;
  const from = document.getElementById("customFrom")?.value;
  const to = document.getElementById("customTo")?.value;

  const now = new Date();
  const year = now.getFullYear();
  const monthName = now.toLocaleDateString("en-US", { month: "long" });

  if (from && to) {
    return `Custom Range: ${from} to ${to}`;
  }

  if (filter === "thisMonth") {
    return `This Month (${monthName} ${year})`;
  } else if (filter === "lastMonth") {
    const last = new Date();
    last.setMonth(last.getMonth() - 1);
    const lastMonth = last.toLocaleDateString("en-US", { month: "long" });
    return `Last Month (${lastMonth} ${last.getFullYear()})`;
  } else if (filter === "thisYear") {
    return `This Year (${year})`;
  }

  return "All Time";
}

window.exportPDF = () => {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  // Заголовок
  doc.setFontSize(18);
  doc.setTextColor(33, 37, 41);
  doc.text("Bookkeeping Report", 105, 15, { align: "center" });

  // Період (виправлено тут)
  const periodText = getSelectedPeriodText();
  doc.setFontSize(12);
  doc.setTextColor(100);
  doc.text(`Period: ${periodText}`, 14, 25);

  // Фінансова таблиця
  doc.autoTable({
    startY: 35,
    head: [["Metric", "Value"]],
    body: [
      ["Total Income", $("totalIncome").innerText],
      ["Total Expenses", $("totalExpenses").innerText],
      ["Net Profit", $("netProfit").innerText],
      ["Total VAT", $("totalVat").innerText],
    ],
    headStyles: { fillColor: [37, 99, 235], textColor: 255 },
    styles: { fontSize: 11 },
    margin: { left: 14, right: 14 }
  });

  let finalY = doc.lastAutoTable.finalY;

  // Додавання графіку
  const chartCanvas = document.getElementById("summaryChart");
  if (chartCanvas) {
    const chartImage = chartCanvas.toDataURL("image/png", 1.0);
    doc.addImage(chartImage, "PNG", 14, finalY + 10, 180, 80);
    finalY += 95;
  }

  // 📍 Брендинг-футер
  doc.setFontSize(10);
  doc.setTextColor(150);
  //  doc.text("Generated with SmartWerk", 105, 290, { align: "center" });

  // Завантаження
  doc.save("smartwerk-bookkeeper-report.pdf");
};


    
onAuthStateChanged(auth, user => {
  if (!user) return location.href = "login.html";
  loadBookkeeperData(user.uid);

  ["clientFilter", "filterBy", "customFrom", "customTo"].forEach(id => {
    $(id).onchange = () => loadBookkeeperData(user.uid);
  });
});

    
  </script>
</body>
</html>

