<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ“Š SmartWerk Bookkeeper</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <link rel="stylesheet" href="bookkeeper.css" />
</head>
<body>
  <h1>ğŸ“’ My Bookkeeper</h1>
  <a href="dashboard.html" class="btn">â† Back to Dashboard</a>
  <button class="btn" onclick="exportCSV()">ğŸ“ Export CSV</button>
  <button class="btn btn-primary" onclick="exportPDF()">ğŸ“„ Export PDF</button>

  <div class="filters">
    <label>Client:
      <select id="clientFilter">
        <option value="">All Clients</option>
      </select>
    </label>
    <label>Period:
      <select id="filterBy">
        <option value="all">All time</option>
        <option value="thisYear">This Year</option>
        <option value="thisMonth">This Month</option>
        <option value="lastMonth">Last Month</option>
      </select>
    </label>
    <label>From: <input type="date" id="customFrom"></label>
    <label>To: <input type="date" id="customTo"></label>
  </div>

  <div class="stats">
    <div class="card"><h2>Total Income</h2><p id="totalIncome">â‚¬0</p></div>
    <div class="card"><h2>Total Expenses</h2><p id="totalExpenses">â‚¬0</p></div>
    <div class="card"><h2>Net Profit</h2><p id="netProfit">â‚¬0</p></div>
    <div class="card"><h2>Total VAT</h2><p id="totalVat">â‚¬0</p></div>
    <div class="card">
      <h2>Annual Target</h2>
      <p>â‚¬<span id="targetValue">50,000</span></p>
      <div class="progress-container">
        <div class="progress-bar" id="targetProgress" style="width: 0%">0%</div>
      </div>
    </div>
  </div>

  <div class="section">
    <h2>ğŸ“Š Income vs Expenses</h2>
    <canvas id="summaryChart" height="100"></canvas>
  </div>

  <div class="section upcoming">
    <div class="card">
      <h2>ğŸ“… Upcoming Invoice Due Dates</h2>
      <ul id="upcomingInvoices"></ul>
    </div>
    <div class="card">
      <h2>ğŸ’¸ Upcoming Expenses</h2>
      <ul id="upcomingExpenses"></ul>
    </div>
  </div>

  <section class="section alerts">
  <h2>ğŸ§  Smart Suggestions</h2>
  <ul id="smartSuggestions"></ul>
</section>

  <div class="section">
    <h2>ğŸ“¥ Import CSV (Clients / Expenses)</h2>
    <input type="file" id="csvUpload" accept=".csv" />
    <button class="btn" onclick="importCSV()">ğŸ“‚ Import</button>
  </div>

  <footer>Â© 2025 SmartWerk</footer>

  <script type="module">

import {
  initializeApp,
  getApps,
  getApp
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import {
  getAuth,
  onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import {
  getFirestore,
  collection,
  getDocs,
  onSnapshot
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAp397Ax_jaMI85vOXicOi61g64HvvA_Kg",
  authDomain: "smartwerk8520.firebaseapp.com",
  projectId: "smartwerk8520",
  appId: "1:607670981972:web:c07103c981c86860d724c1"
};

const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const $ = id => document.getElementById(id);

let summaryChart = null;

function formatCurrency(eur) {
  return "â‚¬" + (eur || 0).toLocaleString("nl-NL", {
    minimumFractionDigits: 2
  });
}

function filterByPeriod(date, filter, from, to) {
  const d = new Date(date);
  const now = new Date();
  const thisMonth = now.getMonth();
  const thisYear = now.getFullYear();
  const lastMonth = new Date(now);
  lastMonth.setMonth(thisMonth - 1);
  const fromDate = from ? new Date(from) : null;
  const toDate = to ? new Date(to) : null;

  if (fromDate && toDate) return d >= fromDate && d <= toDate;

  switch (filter) {
    case "thisMonth":
      return d.getMonth() === thisMonth && d.getFullYear() === thisYear;
    case "lastMonth":
      return d.getMonth() === lastMonth.getMonth() && d.getFullYear() === lastMonth.getFullYear();
    case "thisYear":
      return d.getFullYear() === thisYear;
    default:
      return true;
  }
}

async function loadBookkeeperData(uid) {
  const [invoiceSnap, expenseSnap, clientSnap] = await Promise.all([
    getDocs(collection(db, "users", uid, "invoices")),
    getDocs(collection(db, "users", uid, "expenses")),
    getDocs(collection(db, "users", uid, "clients"))
  ]);

  const filter = $("filterBy").value;
  const from = $("customFrom").value;
  const to = $("customTo").value;

  let invoices = invoiceSnap.docs
    .map(doc => doc.data())
    .filter(i => filterByPeriod(i.invoiceDate || i.date, filter, from, to));
  let expenses = expenseSnap.docs
    .map(doc => doc.data())
    .filter(e => filterByPeriod(e.date, filter, from, to));

  const incomeByClient = {};
  invoices.forEach(inv => {
    if (!inv.clientName) return;
    incomeByClient[inv.clientName] = (incomeByClient[inv.clientName] || 0) + (inv.grandTotal || 0);
  });

  const selectedClient = $("clientFilter").value;
  if (selectedClient) {
    invoices = invoices.filter(i => i.clientName === selectedClient);
  }

  const totalIncome = invoices.reduce((sum, i) => sum + (i.grandTotal || 0), 0);
  const totalVat = invoices.reduce((sum, i) => sum + (i.totalVat || 0), 0);
  const totalExpenses = expenses.reduce((sum, e) => sum + (e.amount || 0), 0);
  const netProfit = totalIncome - totalExpenses;

  $("totalIncome").innerText = formatCurrency(totalIncome);
  $("totalVat").innerText = formatCurrency(totalVat);
  $("totalExpenses").innerText = formatCurrency(totalExpenses);
  $("netProfit").innerText = formatCurrency(netProfit);

  const target = 50000;
  const percent = Math.min(100, Math.round((totalIncome / target) * 100));
  $("targetProgress").style.width = percent + "%";
  $("targetProgress").innerText = percent + "%";

  drawChart(invoices, expenses);
  loadUpcomingInvoices(invoices);
  loadUpcomingExpenses(expenses);
  populateClientDropdown(clientSnap.docs.map(d => d.data()));
  loadSmartSuggestions(invoices, expenses, target);

}

 function loadSmartSuggestions(invoices, expenses, targetIncome = 50000) {
  const suggestions = [];
  const now = new Date();
  const lastMonth = new Date(now);
  lastMonth.setMonth(now.getMonth() - 1);
  const currentMonthStr = now.toISOString().slice(0, 7);
  const prevMonthStr = lastMonth.toISOString().slice(0, 7);

  const formatDate = d => new Date(d);

  // Unpaid invoices > 30 days
  const unpaidOld = invoices.filter(i => {
    const due = formatDate(i.dueDate);
    return i.status !== "Paid" && due && (now - due) > 30 * 24 * 60 * 60 * 1000;
  });
  if (unpaidOld.length > 0) {
    suggestions.push(`ğŸ“Œ You have <strong>${unpaidOld.length}</strong> unpaid invoice(s) older than 30 days.`);
  }

  // Income this month vs last month
  const grouped = {};
  invoices.forEach(i => {
    const m = (i.invoiceDate || i.date || "").slice(0, 7);
    grouped[m] = (grouped[m] || 0) + (i.grandTotal || 0);
  });

  const current = grouped[currentMonthStr] || 0;
  const previous = grouped[prevMonthStr] || 0;
  if (previous > 0) {
    const diff = ((current - previous) / previous) * 100;
    if (diff < -10) {
      suggestions.push(`ğŸ“‰ Income dropped <strong>${Math.abs(diff).toFixed(1)}%</strong> compared to last month.`);
    }
  }

  // Avg. payment time
  const paid = invoices.filter(i => i.status === "Paid" && i.paidDate && i.invoiceDate);
  if (paid.length > 0) {
    const avgDays = Math.round(paid.reduce((sum, i) => {
      return sum + Math.max(0, (new Date(i.paidDate) - new Date(i.invoiceDate)) / (1000 * 60 * 60 * 24));
    }, 0) / paid.length);
    suggestions.push(`ğŸ“† Average payment time: <strong>${avgDays} days</strong>`);
  }

  // Target income progress
  const totalIncome = invoices.reduce((sum, i) => sum + (i.grandTotal || 0), 0);
  const percent = Math.min(100, Math.round((totalIncome / targetIncome) * 100));
  suggestions.push(`ğŸ¯ You have reached <strong>${percent}%</strong> of your annual income goal.`);

  // Expense change
  const groupedExp = {};
  expenses.forEach(e => {
    const m = (e.date || "").slice(0, 7);
    groupedExp[m] = (groupedExp[m] || 0) + (e.amount || 0);
  });

  const currExp = groupedExp[currentMonthStr] || 0;
  const prevExp = groupedExp[prevMonthStr] || 0;
  if (prevExp > 0) {
    const expDiff = ((currExp - prevExp) / prevExp) * 100;
    const direction = expDiff > 0 ? "increased" : "decreased";
    suggestions.push(`ğŸ’¸ Expenses have <strong>${direction}</strong> by ${Math.abs(expDiff).toFixed(1)}% this month.`);
  }

  // Render to UI
  const container = document.getElementById("smartSuggestions");
  container.innerHTML = "";
  suggestions.forEach(s => {
    const li = document.createElement("li");
    li.innerHTML = s;
    container.appendChild(li);
  });
}   
    

function drawChart(invoices, expenses) {
  const incomeMap = {}, expenseMap = {};

  invoices.forEach(i => {
    const m = (i.invoiceDate || i.date || "").slice(0, 7);
    incomeMap[m] = (incomeMap[m] || 0) + (i.grandTotal || 0);
  });

  expenses.forEach(e => {
    const m = (e.date || "").slice(0, 7);
    expenseMap[m] = (expenseMap[m] || 0) + (e.amount || 0);
  });

  const labels = Array.from(new Set([...Object.keys(incomeMap), ...Object.keys(expenseMap)])).sort();
  const incomeData = labels.map(m => incomeMap[m] || 0);
  const expenseData = labels.map(m => expenseMap[m] || 0);

  const ctx = $("summaryChart").getContext("2d");
  if (summaryChart) summaryChart.destroy();

  summaryChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        { label: "Income", data: incomeData, backgroundColor: "#22c55e" },
        { label: "Expenses", data: expenseData, backgroundColor: "#ef4444" }
      ]
    },
    options: {
      responsive: true,
      plugins: { legend: { position: "top" } }
    }
  });
}

function loadUpcomingInvoices(invoices) {
  const list = $("upcomingInvoices");
  list.innerHTML = "";

  const upcoming = invoices
    .filter(i => i.dueDate && new Date(i.dueDate) > new Date())
    .sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate))
    .slice(0, 5);

  if (upcoming.length === 0) {
    const li = document.createElement("li");
    li.textContent = "ğŸ“­ No upcoming invoices";
    li.style.color = "#94a3b8"; // Ğ¿Ñ€Ğ¸Ğ³Ğ»ÑƒÑˆĞµĞ½Ğ¸Ğ¹ ÑÑ–Ñ€Ğ¸Ğ¹
    list.appendChild(li);
    return;
  }

  upcoming.forEach(i => {
    const li = document.createElement("li");
    const due = new Date(i.dueDate).toLocaleDateString("en-GB", {
      day: "numeric", month: "short", year: "numeric"
    });
    li.textContent = `${i.clientName || "Unnamed"} â€“ due ${due}`;
    list.appendChild(li);
  });
}

function loadUpcomingExpenses(expenses) {
  const list = $("upcomingExpenses");
  list.innerHTML = "";
  expenses.filter(e => e.date && new Date(e.date) > new Date())
    .sort((a, b) => new Date(a.date) - new Date(b.date))
    .slice(0, 5)
    .forEach(e => {
      const li = document.createElement("li");
      li.textContent = `${e.category || "Expense"} â€“ due ${e.date}`;
      list.appendChild(li);
    });
}

function populateClientDropdown(clients) {
  const select = $("clientFilter");
  const currentValue = select.value; // ğŸ”¸ Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ğ¼Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ

  select.innerHTML = `<option value="">All Clients</option>`;
  clients.forEach(c => {
    if (!c.clientName) return;
    const opt = document.createElement("option");
    opt.value = c.clientName;
    opt.textContent = c.clientName;
    select.appendChild(opt);
  });

  // ğŸ”¸ ĞŸÑ–ÑĞ»Ñ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ â€” Ğ²Ñ–Ğ´Ğ½Ğ¾Ğ²Ğ»ÑÑ”Ğ¼Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ½Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ
  select.value = currentValue;
}

window.exportCSV = () => {
  const rows = [
    ["Metric", "Value"],
    ["Total Income", $("totalIncome").innerText],
    ["Total Expenses", $("totalExpenses").innerText],
    ["Net Profit", $("netProfit").innerText],
    ["Total VAT", $("totalVat").innerText]
  ];
  let csvContent = "data:text/csv;charset=utf-8," + rows.map(e => e.join(",")).join("\n");
  const encodedUri = encodeURI(csvContent);
  const link = document.createElement("a");
  link.setAttribute("href", encodedUri);
  link.setAttribute("download", "bookkeeper-summary.csv");
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

window.exportPDF = () => {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(18);
  doc.text("SmartWerk Bookkeeper Report", 105, 15, { align: "center" });
  doc.setFontSize(12);
  doc.text("Overview:", 14, 30);
  doc.autoTable({
    startY: 35,
    head: [["Metric", "Value"]],
    body: [
      ["Total Income", $("totalIncome").innerText],
      ["Total Expenses", $("totalExpenses").innerText],
      ["Net Profit", $("netProfit").innerText],
      ["Total VAT", $("totalVat").innerText]
    ]
  });

  doc.setFontSize(10);
  doc.text("Generated with SmartWerk", 105, 285, { align: "center" });
  doc.save("bookkeeper-summary.pdf");
};

onAuthStateChanged(auth, user => {
  if (!user) return location.href = "login.html";
  loadBookkeeperData(user.uid);

  ["clientFilter", "filterBy", "customFrom", "customTo"].forEach(id => {
    $(id).onchange = () => loadBookkeeperData(user.uid);
  });
});

    
  </script>
</body>
</html>

